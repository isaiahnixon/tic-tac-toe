{"version":3,"sources":["index.js","useReducerWithHistory.js"],"names":["gameState","gameContext","createContext","Board","squares","useContext","state","react_default","a","createElement","react","className","Square","boardId","props","_useContext2","dispatch","stepNumber","xIsNext","squaresCopy","Object","objectSpread","assign","onClick","calculateWinner","type","lines","i","length","_lines$i","slicedToArray","b","c","ReactDOM","render","_useReducerWithHistor","reducer","history","useRef","_useState","useState","_useState2","index","setIndex","canUndo","canRedo","current","action","newState","slice","push","useReducerWithHistory","Array","fill","_useReducerWithHistor2","undo","redo","reset","useEffect","status","context","winner","complete","values","isArray","includes","isTie","Provider","value","index_esm","disabled","document","getElementById"],"mappings":"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","file":"static/js/main.b5dfc280.chunk.js","sourcesContent":["import React, { useEffect, Fragment, createContext, useContext } from 'react';\nimport { FaUndo, FaRedo, FaSync } from \"react-icons/fa\"\nimport useReducerWithHistory from \"./useReducerWithHistory\"\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\n// Initialize a state for the game\nlet gameState = null\n\n// Initialize a context for the game\nconst gameContext = createContext()\n\nfunction Game() {\n  // Create the reducer pattern for the state\n  const [state, dispatch, canUndo, undo, canRedo, redo, reset] = useReducerWithHistory(\n    (state, action) => {\n      switch (action.type) {\n        case \"SQUARE_CLICKED\":\n          return { ...state, squares: action.squares, stepNumber: action.stepNumber, xIsNext: action.xIsNext }\n        default:\n          return { ...state }\n      }\n    },\n    gameState || {\n      squares: Array(9).fill(null),\n      stepNumber: 0,\n      xIsNext: false,\n    }\n  )\n\n  // Grab the neccesary values from the state\n  const { squares, xIsNext } = state\n\n  // Effect to synchronize the gameState variable\n  useEffect(() => {\n    gameState = state\n  })\n\n  // Define the context object\n  const context = {state, dispatch}\n\n  // Calculate the winner\n  const winner = calculateWinner(squares)\n\n  // Calculate the status\n  let status;\n  let complete = false;\n  if (winner) {\n    status = 'Winner: ' + winner\n    complete = true\n  } else if (isTie(squares)) {\n    status = \"Tie!\"\n    complete = true\n  } else {\n    status = 'Next player: ' + (xIsNext ? 'X' : 'O')\n  }\n\n  // Provide that state as context for the Board\n  return (\n    <div className=\"game\">\n      <div className=\"game-board\">\n        <h1>Tic-Tac-Toe</h1>\n        <gameContext.Provider value={context}>\n          <Board />\n        </gameContext.Provider>\n        <div className=\"game-info\">\n          <div>{status}</div>\n          {complete ? <button onClick={reset}>Reset <FaSync/></button> \n          : <Fragment>\n              <button onClick={undo} disabled={!canUndo()}>Undo <FaUndo/></button>\n              <button onClick={redo} disabled={!canRedo()}>Redo <FaRedo/></button>\n            </Fragment>}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nfunction Board() {\n  // Inherit state from context\n  const {state} = useContext(gameContext)\n\n  // Grab the squares from the state\n  const { squares } = state\n  \n  // Provide values and IDs for the squares\n  return (\n    <Fragment>\n     { squares && (\n      <Fragment>\n        <div className=\"board-row\">\n          <Square boardId={0}>{squares[0]}</Square>\n          <Square boardId={1}>{squares[1]}</Square>\n          <Square boardId={2}>{squares[2]}</Square>\n        </div>\n        <div className=\"board-row\">\n          <Square boardId={3}>{squares[3]}</Square>\n          <Square boardId={4}>{squares[4]}</Square>\n          <Square boardId={5}>{squares[5]}</Square>\n        </div>\n        <div className=\"board-row\">\n          <Square boardId={6}>{squares[6]}</Square>\n          <Square boardId={7}>{squares[7]}</Square>\n          <Square boardId={8}>{squares[8]}</Square>\n        </div>\n      </Fragment>)} \n    </Fragment>\n    \n  )\n}\n\nfunction Square(props) {\n  // Inherit state and dispatch from context\n  const { state, dispatch } = useContext(gameContext)\n\n  // Grab the neccesary values from the state\n  const { squares, stepNumber, xIsNext } = state\n\n  let squaresCopy = {...squares}\n  let stepNumberCopy = stepNumber\n  let xIsNextCopy = xIsNext\n\n  // Function to handle all square clicks\n  const handleClick = () => {\n    // If nobody has won, and the square is not already set,\n    if (!calculateWinner(squares) && !squares[props.boardId]) {\n      // Update the state\n      squaresCopy[props.boardId] = xIsNext ? 'X' : 'O'\n      stepNumberCopy = stepNumber + 1\n      xIsNextCopy = !xIsNext\n\n      // Dispatch the new state.\n      dispatch({ type: 'SQUARE_CLICKED', squares: squaresCopy, stepNumber: stepNumberCopy, xIsNext: xIsNextCopy })\n    }\n  }\n\n  // Render a button with the passed in properties,\n  // Overriding only onClick and className\n  return (\n    <button {...props} onClick={handleClick} className=\"square\" />\n  )\n}\n\n// Helper function for determining a winner\nfunction calculateWinner(squares) {\n  const lines = [\n    [0, 1, 2],\n    [3, 4, 5],\n    [6, 7, 8],\n    [0, 3, 6],\n    [1, 4, 7],\n    [2, 5, 8],\n    [0, 4, 8],\n    [2, 4, 6],\n  ];\n  for (let i = 0; i < lines.length; i++) {\n    const [a, b, c] = lines[i];\n    if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\n      return squares[a];\n    }\n  }\n  return null;\n}\n\n// Helper function to determine if the game is a tie.\nfunction isTie(squares) {\n  // Convert the squares to an array if it is an object\n  if (squares instanceof Object) {\n    squares = Object.values(squares)\n  }\n\n  // If squares is an array, check if it is full\n  if (Array.isArray(squares)) {\n    return !squares.includes(null)\n  }\n\n  // Unknown type\n  return false\n}\n\n// The final render call\nReactDOM.render(\n  <Game />,\n  document.getElementById('root')\n);","import { useRef, useState } from 'react';\n\n// Custom hook for adding history functions to a reducer pattern.\nexport default function useReducerWithHistory(reducer, state) {\n    // Use a reference for persistent history\n    const history = useRef([state])\n  \n    // Set some state for the current index\n    const [index, setIndex] = useState(0)\n  \n    // Function to determin if undo is possible\n    function canUndo() {\n      return (index > 0)\n    }\n  \n    // Function to rewind index by 1\n    function undo() {\n      setIndex(canUndo() ? index - 1 : index)\n    }\n  \n    // Function to determine if redo is possible\n    function canRedo() {\n      return (index < history.current.length - 1)\n    }\n  \n    // Function to increase index by 1\n    function redo() {\n      setIndex(canRedo() ? index + 1 : index)\n    }\n  \n    // Dispatcher that preserves history when calling the reducer\n    function dispatch(action) {\n      const newState = reducer(history.current[index], action)\n      history.current = history.current.slice(0, index + 1)\n      history.current.push(newState)\n      setIndex(history.current.length - 1)\n    }\n\n    // Function to reset the history to the start\n    function reset() {\n      history.current = history.current.slice(0, 1)\n      setIndex(0)\n    }\n  \n    // Return the current state, and the new functions\n    return [history.current[index], dispatch, canUndo, undo, canRedo, redo, reset]\n  }"],"sourceRoot":""}